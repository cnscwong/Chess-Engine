#include <bitset>
#include <iostream>
#include <string>

/*----------------------------------*/
/*       BOARD REPRESENTATION       */
/*----------------------------------*/

// 8x8 chess board represented as 64 bits
#define Bitboard unsigned long long

// bitboards representing the files and ranks of a chessboard
constexpr Bitboard FILE_A = 0x0101010101010101;
constexpr Bitboard FILE_B = 0x0202020202020202;
constexpr Bitboard FILE_C = 0x0404040404040404;
constexpr Bitboard FILE_D = 0x0808080808080808;
constexpr Bitboard FILE_E = 0x1010101010101010;
constexpr Bitboard FILE_F = 0x2020202020202020;
constexpr Bitboard FILE_G = 0x4040404040404040;
constexpr Bitboard FILE_H = 0x8080808080808080;

constexpr Bitboard RANK_1 = 0xFF00000000000000;
constexpr Bitboard RANK_2 = 0x00FF000000000000;
constexpr Bitboard RANK_3 = 0x0000FF0000000000;
constexpr Bitboard RANK_4 = 0x000000FF00000000;
constexpr Bitboard RANK_5 = 0x00000000FF000000;
constexpr Bitboard RANK_6 = 0x0000000000FF0000;
constexpr Bitboard RANK_7 = 0x000000000000FF00;
constexpr Bitboard RANK_8 = 0x00000000000000FF;

constexpr Bitboard ALL_SET = 0xFFFFFFFFFFFFFFFF;

// Bitboard macros
#define set(board, square) (board |= 1ULL << square)
#define get(board, square) ((board & (1ULL << square)) ? 1:0)
#define clear(board, square) if(get(board, square)) board ^= (1ULL << square)

// enum for all squares, corresponds to their position on the bitboard
enum Square {
    A8, B8, C8, D8, E8, F8, G8, H8,
    A7, B7, C7, D7, E7, F7, G7, H7,
    A6, B6, C6, D6, E6, F6, G6, H6,
    A5, B5, C5, D5, E5, F5, G5, H5,
    A4, B4, C4, D4, E4, F4, G4, H4,
    A3, B3, C3, D3, E3, F3, G3, H3,
    A2, B2, C2, D2, E2, F2, G2, H2,
    A1, B1, C1, D1, E1, F1, G1, H1,
    numSquares
};

std::string toSquare[] = {
"a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8",
"a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7",
"a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6",
"a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5",
"a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4",
"a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3",
"a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2",
"a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1"
};

//Enum used to track colour of pieces... etc.
enum Colour {White, Black, numColour};

bool validSquare(int square){
    return square >= 0 && square < 64;
}

// counts number of set bits in bitboard
static inline int countBits(Bitboard board){
    int count = 0;
    while(board){
        count++;
        board &= board - 1;
    }

    return count;
}

// finds lsb and returns index
static inline int findLSB(Bitboard b){
    if(b == 0){
        return -1;
    }

    return countBits((b & -b) - 1);
}

// debug print function
void printBitBoard(Bitboard board){
    for(int rank = 0; rank < 8; rank++){
        std::cout << 8 - rank << "   ";
        for(int file = 0; file < 8; file++){
            std::cout << get(board, (rank*8 + file)) << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
    std::cout << "    A B C D E F G H" << std::endl << std::endl << "ULL:" << board << std::endl << std::endl;
}

/*----------------------------------*/
/*          MAGIC BITBOARDS         */
/*----------------------------------*/

constexpr Bitboard NO_BORDER = 0x007E7E7E7E7E7E00;

// generates a bitmask for bishop at specified square to use for magic bitboard
Bitboard genBishopMask(int square){
    Bitboard mask = 0ULL;

    int sRank = square / 8;
    int sFile = square % 8;
    int i, j;

    for(i = sRank + 1, j = sFile + 1; i < 7 && j < 7; i++, j++){
        set(mask, (i*8 + j));
    }

    for(i = sRank - 1, j = sFile - 1; i > 0 && j > 0; i--, j--){
        set(mask, (i*8 + j));
    }

    for(i = sRank + 1, j = sFile - 1; i < 7 && j > 0; i++, j--){
        set(mask, (i*8 + j));
    }

    for(i = sRank - 1, j = sFile + 1; i > 0 && j < 7; i--, j++){
        set(mask, (i*8 + j));
    }

    return mask;
}

//bit counts for all masks generated by genBishopMask()
const int bishopMaskBitcount[64] = {
    6, 5, 5, 5, 5, 5, 5, 6, 
    5, 5, 5, 5, 5, 5, 5, 5, 
    5, 5, 7, 7, 7, 7, 5, 5, 
    5, 5, 7, 9, 9, 7, 5, 5, 
    5, 5, 7, 9, 9, 7, 5, 5, 
    5, 5, 7, 7, 7, 7, 5, 5, 
    5, 5, 5, 5, 5, 5, 5, 5, 
    6, 5, 5, 5, 5, 5, 5, 6
};

// generates possible bishop moves until it hits a piece (Hits both colours, attacks will be handled during move generation)
Bitboard genBishopMoves(int square, Bitboard boardState){
    Bitboard moves = 0ULL;

    int sRank = square / 8;
    int sFile = square % 8;
    int i, j;

    for(i = sRank + 1, j = sFile + 1; i <= 7 && j <= 7; i++, j++){
        set(moves, (i*8 + j));
        if(get(boardState, (i*8 + j))) break;
    }

    for(i = sRank - 1, j = sFile - 1; i >= 0 && j >= 0; i--, j--){
        set(moves, (i*8 + j));
        if(get(boardState, (i*8 + j))) break;
    }

    for(i = sRank + 1, j = sFile - 1; i <= 7 && j >= 0; i++, j--){
        set(moves, (i*8 + j));
        if(get(boardState, (i*8 + j))) break;
    }

    for(i = sRank - 1, j = sFile + 1; i >= 0 && j <= 7; i--, j++){
        set(moves, (i*8 + j));
        if(get(boardState, (i*8 + j))) break;
    }

    return moves;
}

// generates a bitmask for rook at specified square to use for magic bitboard
Bitboard genRookMask(int square){
    Bitboard mask = 0ULL;

    int sRank = square / 8;
    int sFile = square % 8;
    int i, j;

    for(i = sRank + 1; i < 7; i++){
        set(mask, (i*8 + sFile));
    }

    for(i = sRank - 1; i > 0; i--){
        set(mask, (i*8 + sFile));
    }

    for(j = sFile + 1;j < 7; j++){
        set(mask, (sRank*8 + j));
    }

    for(j = sFile - 1;j > 0; j--){
        set(mask, (sRank*8 + j));
    }

    return mask;
}

//bit counts for all masks generated by genRookMask()
const int rookMaskBitcount[64] = {
    12, 11, 11, 11, 11, 11, 11, 12, 
    11, 10, 10, 10, 10, 10, 10, 11, 
    11, 10, 10, 10, 10, 10, 10, 11, 
    11, 10, 10, 10, 10, 10, 10, 11, 
    11, 10, 10, 10, 10, 10, 10, 11, 
    11, 10, 10, 10, 10, 10, 10, 11, 
    11, 10, 10, 10, 10, 10, 10, 11, 
    12, 11, 11, 11, 11, 11, 11, 12
};

// generates possible rook moves until it hits a piece (Hits both colours, attacks will be handled during move generation)
Bitboard genRookMoves(int square, Bitboard boardState){
    Bitboard moves = 0ULL;

    int sRank = square / 8;
    int sFile = square % 8;
    int i, j;

    for(i = sRank + 1; i <= 7; i++){
        set(moves, (i*8 + sFile));
        if(get(boardState, (i*8 + sFile))) break;
    }

    for(i = sRank - 1; i >= 0; i--){
        set(moves, (i*8 + sFile));
        if(get(boardState, (i*8 + sFile))) break;
    }

    for(j = sFile + 1;j <= 7; j++){
        set(moves, (sRank*8 + j));
        if(get(boardState, (sRank*8 + j))) break;
    }

    for(j = sFile - 1;j >= 0; j--){
        set(moves, (sRank*8 + j));
        if(get(boardState, (sRank*8 + j))) break;
    }

    return moves;
}

// returns occupancy map for each index from 0 to 4095
Bitboard mapOccupancy(int index, Bitboard mask){
    Bitboard map = 0ULL;
    int bits = countBits(mask);

    for(int c = 0; c < bits; c++){
        int square = findLSB(mask);
        clear(mask, square);
        if(index & (1 << c)) set(map, square);
    }

    return map;
}

unsigned int randNum = 1804289383;

// 32 bit random number generator
unsigned int random32(){
    unsigned int num = randNum;

    num ^= num << 13;
    num ^= num >> 17;
    num ^= num << 5;

    randNum = num;
    
    return num;
}

//64 bit random number generator
unsigned long long random64(){
    unsigned long long u1, u2, u3, u4;
    
    u1 = (unsigned long long)(random32()) & 0xFFFF;
    u2 = (unsigned long long)(random32()) & 0xFFFF;
    u3 = (unsigned long long)(random32()) & 0xFFFF;
    u4 = (unsigned long long)(random32()) & 0xFFFF;

    return u1 | (u2 << 16) | (u3 << 32) | (u4 << 48);
}

// macro to generate magic number candidates
#define generateMagic() (random64() & random64() & random64())


/*----------------------------------*/
/*       Pre-calculating moves      */
/*----------------------------------*/

Bitboard pawn_attacks[numColour][numSquares];
Bitboard knight_moves[numSquares];
Bitboard king_moves[numSquares];

// generates possible W/B pawn moves at specified square
Bitboard genPawnAttacks(Colour c, int square){
    Bitboard temp = 1ULL << square;
    Bitboard attack = 0ULL;
    if(c == White){
        attack |= ~FILE_A & temp >> 7;
        attack |= ~FILE_H & temp >> 9;
    }else{
        attack |= ~FILE_A & temp << 9;
        attack |= ~FILE_H & temp << 7;
    }

    return attack;
}

// generates possible knight moves at specified square
Bitboard genKnightMoves(int square){
    Bitboard temp = 1ULL << square;
    Bitboard moves = 0ULL;

    moves |= ~FILE_A & ~FILE_B & temp >> 6;
    moves |= ~FILE_H & ~FILE_G & temp >> 10;
    moves |= ~FILE_A & temp >> 15;
    moves |= ~FILE_H & temp >> 17;

    moves |= ~FILE_H & ~FILE_G & temp << 6;
    moves |= ~FILE_A & ~FILE_B & temp << 10;
    moves |= ~FILE_H & temp << 15;
    moves |= ~FILE_A & temp << 17;

    return moves;
}

// generates possible king moves at specified square
Bitboard genKingMoves(int square){
    Bitboard temp = 1ULL << square;
    Bitboard moves = 0ULL;
    
    //right moves
    moves |= ~FILE_A & temp >> 7;
    moves |= ~FILE_A & temp << 1;
    moves |= ~FILE_A & temp << 9;

    //up down
    moves |= temp >> 8;
    moves |= temp << 8;

    //left moves
    moves |= ~FILE_H & temp >> 9;
    moves |= ~FILE_H & temp >> 1;
    moves |= ~FILE_H & temp << 7;

    return moves;
}

void initLookupTables(){
    for(int i = 0; i < 64; i++){
        pawn_attacks[White][i] = genPawnAttacks(White, i);
        pawn_attacks[Black][i] = genPawnAttacks(Black, i);
        
        king_moves[i] = genKingMoves(i);

        knight_moves[i] = genKnightMoves(i);
    }
}

/*----------------------------------*/
/*               MAIN               */
/*----------------------------------*/

int main(){
    printBitBoard(generateMagic());
    return 0;
}